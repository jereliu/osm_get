vertex_set <-
grep("^v[0-9]* ", target_txt, value = TRUE) %>%
# keep only "123" from "v123 a b c"
gsub("^v| [[:punct:][:digit:][:blank:]]+", "",.) %>%
as.numeric %>% unique %>% sort
facet_list <- #keep this for 4.2
grep("^f ", target_txt, value = TRUE) %>%
# keep only "a b c" from "f a b c"
gsub("^f ", "", .) %>%
strsplit(" ")  %>% lapply(as.numeric)
facet_set <-
facet_list %>% unlist %>% unique %>% sort
# see if any vextex needed by facet is not in vertex_set
if (!setequal(facet_set, vertex_set)){
lost_vert <- setdiff(facet_set, vertex_set)
extra_vert <- setdiff(vertex_set, vertex_set)
if (length(lost_vert) > 0){
cat("\n these vertex are needed and can't be found in file: ",
paste(lost_vert, collapse = ", "), "\n")
return(1)
} else if (length(extra_vert) > 0){
stop("\n these vertex are not needed by facet in file: ",
paste(extra_vert, collapse = ", "), "\n")
return(2)
} else {
stop("\n facet set and vertex set are not equal, weird. \n")
return(3)
}
}
source("./func/osm_helper.R")
require(rgl)
require(dplyr)
require(magrittr)
file_dir <-
"/Users/Jeremiah/Dropbox/Research/Harvard/1. BostonPol/Analysis/Elem/2/data/3d_building_osm"
#### 3. read-in 3d OBJ file and keep only the building objects ####
in_dir <- paste0(file_dir, "/Data_3d/")
out_dir <- paste0(file_dir, "/Data_3d_building/")
file_list <-
list.files(in_dir) %>%
grep("*.obj$", ., value = TRUE) %>%
gsub("\\.obj$", "", .)
key = "^Building$"
file_name
verbose = TRUE
cat("Processing", file_name, "..")
# 1. read file into string ===
txt <- readLines(paste0(in_dir, file_name, ".obj"))
# mark vertex index, "v a b c" => "v22 a b c"
v_idx <- grep("^v ", txt)
txt[v_idx] <-
paste0("v", 1:length(v_idx)) %>%
mapply(gsub, "^v", ., txt[v_idx]) %>%
as.vector
### 2. group txt into list of named objects ===
# output: a two-tier list. First by group
# (e.g. comment, Road, Building etc),
# then by object (e.g. Building001)
## 2.1 create first order list  by object group ---
# output: group_list (vertex marked)
# obtain idx of group title
group_idx <- grep("^g ", txt)
group_title <- c("comment", txt[group_idx])
group_list <-
# group lines into list by group
list_from_idx(group_idx, txt) %>%
# set title names
set_names(group_title)
## 2.2 create second order list by object ---
# output: group_obj_list (vertex marked)
group_obj_list <-
lapply(group_list,
function(group_txt){
# obtain idx of object title
title_idx <- grep("^o ", group_txt)
title_list <- group_txt[title_idx] %>% gsub("^o ", "", .)
obj_list <-
# for each title, group its lines into one el in list
list_from_idx(title_idx, group_txt) %>%
# set title names
set_names(c("group", title_list))
}
)
### 3. Filtering using the keyword from 'filter' ===
# output: target_list (vertex marked)
# find available object types, print for user validation
group_title_exact <- group_title %>% gsub("^g ", "", .)
types <- group_title_exact %>% unique
types_idx <- grep(key, types)
types_target <- grep(key, types, value = TRUE)
if (verbose) {
cat("\n Available obj types from '", file_name, "' are:\n ")
cat(paste(1:length(types), types, "\n"))
cat("given key is \'", key, "\', below object types will be returned:\n ")
cat(paste(types_idx, types_target, "\n"))
}
# obtain target objects
target_list_raw <-
# first obtain index of target list
grep(key, group_title_exact) %>%
# then retrieve object
(function(idx) group_obj_list[idx])
### 4. Fix vertex ===
# input: target_list_raw (vertex marked)
# output: target_list (vertex index fixed and vertex clean)
target_txt <- unlist(target_list_raw) %>% as.character
## 4.1 First check if vertex set includes facet set match
vertex_set <-
grep("^v[0-9]* ", target_txt, value = TRUE) %>%
# keep only "123" from "v123 a b c"
gsub("^v| [[:punct:][:digit:][:blank:]]+", "",.) %>%
as.numeric %>% unique %>% sort
facet_list <- #keep this for 4.2
grep("^f ", target_txt, value = TRUE) %>%
# keep only "a b c" from "f a b c"
gsub("^f ", "", .) %>%
strsplit(" ")  %>% lapply(as.numeric)
facet_set <-
facet_list %>% unlist %>% unique %>% sort
# see if any vextex needed by facet is not in vertex_set
if (!setequal(facet_set, vertex_set)){
lost_vert <- setdiff(facet_set, vertex_set)
extra_vert <- setdiff(vertex_set, vertex_set)
if (length(lost_vert) > 0){
cat("\n these vertex are needed and can't be found in file: ",
paste(lost_vert, collapse = ", "), "\n")
return(1)
} else if (length(extra_vert) > 0){
stop("\n these vertex are not needed by facet in file: ",
paste(extra_vert, collapse = ", "), "\n")
return(2)
} else {
stop("\n facet set and vertex set are not equal, weird. \n")
return(3)
}
}
fct_idx <- grep("^f ", target_txt)
fct_idx
vtx_idx
vtx_idx <- grep("^v", target_txt)
vtx_idx
vertex_set
hash <- 1:length(vertex_set) %>%
set_names(vertex_set)
hash
hash[256829]
install.packages(hash)
install.packages("hash")
require(hash)
hash_fun <- hash(vertex_set, 1:length(vertex_set))
hash_fun
class(hash_fun)
hash_fun[1]
hash_fun[256834]
hash_fun[[256834]]
hash_fun[["256834"]]
facet_list <- #keep this for 4.2
grep("^f ", target_txt, value = TRUE) %>%
# keep only "a b c" from "f a b c"
gsub("^f ", "", .) %>%
strsplit(" ")
facet_list
facet_set <-
facet_list %>% unlist %>%
as.numeric %>% unique %>% sort
setequal(facet_set, vertex_set)
fct_idx <- grep("^f ", target_txt)
vtx_idx <- grep("^v", target_txt)
hash_fun <-
hash(key = vertex_set,
values = 1:length(vertex_set))
vert
vert <- facet_list[[1]]
vert
hash_fun[vert]
hash_fun[[vert]]
hash_fun["251483"]
251483 %in% vertex_set
hash_fun[251483]
hash_fun <-
hash(key = vertex_set,
values = 1:length(vertex_set))
vertex_set
1:length(vertex_set)
hash_fun <-
hash(key = vertex_set,
values = 1:length(vertex_set))
hash_fun[["256305"]]
hash_fun[[256305]]
vertex_set
h <- hash( letters, 1:26 )
h$a
h$b
h[[ "a" ]]
h[ letters[1:3] ]
hash_fun <-
hash(key = as.character(vertex_set),
values = 1:length(vertex_set))
hash_fun[vert]
vert
"247254" %in% as.character(vertex_set)
vert
hash_fun["247253"]
hash_fun['247253']
hash_fun[['247253']]
hash_fun[[ '247253' ]]
names(hash_fun)
hash_fun$key
hash_fun[[256834]]
hash_fun[["256834"]]
hash_fun["256834"]
1:length(vertex_set)
hash_fun$values
h <- hash( letters, 1:26 )
h[["a"]]
h["a"]
hash_fun <-
hash(key = as.character(vertex_set),
values = 1:length(vertex_set))
hash_fun
hash_fun$keys
hash_fun$key
hash_fun$key %>% class
hash_fun[["256834"]]
h[["256834"]]
h[["a"]]
as.list(1:length(vertex_set))
vertex_set
hash_fun <-
as.list(1:length(vertex_set)) %>%
set_names(as.character(vertex_set))
hash_fun[[vert[1]]]
hash_fun[vert]
hash_fun[vert] %>% unlist
vert_new <- hash_fun[vert] %>% unlist
paste(c("f", vert_new), collapse = " ")
cat("Processing", file_name, "..")
# 1. read file into string ===
txt <- readLines(paste0(in_dir, file_name, ".obj"))
# mark vertex index, "v a b c" => "v22 a b c"
v_idx <- grep("^v ", txt)
txt[v_idx] <-
paste0("v", 1:length(v_idx)) %>%
mapply(gsub, "^v", ., txt[v_idx]) %>%
as.vector
### 2. group txt into list of named objects ===
# output: a two-tier list. First by group
# (e.g. comment, Road, Building etc),
# then by object (e.g. Building001)
## 2.1 create first order list  by object group ---
# output: group_list (vertex marked)
# obtain idx of group title
group_idx <- grep("^g ", txt)
group_title <- c("comment", txt[group_idx])
group_list <-
# group lines into list by group
list_from_idx(group_idx, txt) %>%
# set title names
set_names(group_title)
## 2.2 create second order list by object ---
# output: group_obj_list (vertex marked)
group_obj_list <-
lapply(group_list,
function(group_txt){
# obtain idx of object title
title_idx <- grep("^o ", group_txt)
title_list <- group_txt[title_idx] %>% gsub("^o ", "", .)
obj_list <-
# for each title, group its lines into one el in list
list_from_idx(title_idx, group_txt) %>%
# set title names
set_names(c("group", title_list))
}
)
### 3. Filtering using the keyword from 'filter' ===
# output: target_list (vertex marked)
# find available object types, print for user validation
group_title_exact <- group_title %>% gsub("^g ", "", .)
types <- group_title_exact %>% unique
types_idx <- grep(key, types)
types_target <- grep(key, types, value = TRUE)
if (verbose) {
cat("\n Available obj types from '", file_name, "' are:\n ")
cat(paste(1:length(types), types, "\n"))
cat("given key is \'", key, "\', below object types will be returned:\n ")
cat(paste(types_idx, types_target, "\n"))
}
# obtain target objects
target_list_raw <-
# first obtain index of target list
grep(key, group_title_exact) %>%
# then retrieve object
(function(idx) group_obj_list[idx])
### 4. Fix vertex ===
# input: target_list_raw (vertex marked)
# output: target_list (vertex index fixed and vertex clean)
target_txt <- unlist(target_list_raw) %>% as.character
## 4.1 First check if vertex set includes facet set match
vertex_set <-
grep("^v[0-9]* ", target_txt, value = TRUE) %>%
# keep only "123" from "v123 a b c"
gsub("^v| [[:punct:][:digit:][:blank:]]+", "",.) %>%
as.numeric %>% unique %>% sort
facet_list <- #keep this for 4.2
grep("^f ", target_txt, value = TRUE) %>%
# keep only "a b c" from "f a b c"
gsub("^f ", "", .) %>%
strsplit(" ")
facet_set <-
facet_list %>% unlist %>%
as.numeric %>% unique %>% sort
# see if any vextex needed by facet is not in vertex_set
if (!setequal(facet_set, vertex_set)){
lost_vert <- setdiff(facet_set, vertex_set)
extra_vert <- setdiff(vertex_set, vertex_set)
if (length(lost_vert) > 0){
cat("\n these vertex are needed and can't be found in file: ",
paste(lost_vert, collapse = ", "), "\n")
return(1)
} else if (length(extra_vert) > 0){
stop("\n these vertex are not needed by facet in file: ",
paste(extra_vert, collapse = ", "), "\n")
return(2)
} else {
stop("\n facet set and vertex set are not equal, weird. \n")
return(3)
}
}
## 4.2 Now re-index (hash) vertex in facet command
# note we assume vertex_set == facet_set
fct_idx <- grep("^f ", target_txt)
vtx_idx <- grep("^v", target_txt)
hash_fun <-
as.list(1:length(vertex_set)) %>%
set_names(as.character(vertex_set))
# break, convert, reconstruct all facet commands
target_txt[fct_idx] <-
sapply(facet_list,
function(vert){
# convert using minusand
vert_new <- hash_fun[vert] %>% unlist
# reconstruct
paste(c("f", vert_new), collapse = " ")
}
)
# clean up vertex reference ("v123 a b c" => "v a b c")
target_txt[vtx_idx] <-
target_txt[vtx_idx] %>%
gsub("^v[0-9]* ", "v ", .)
## 4.3 recreate group/object set list (target_list)
grp_idx <- grep("^g ", target_txt)
obj_idx <- grep("^o ", target_txt)
group_list_clean <-
# group lines into list by group
list_from_idx(grp_idx, target_txt) %>%
# set title names
set_names(c(target_txt[grp_idx]))
target_list <-
lapply(group_list_clean,
function(group_txt){
# obtain idx of object title
title_idx <- grep("^o ", group_txt)
title_list <- group_txt[title_idx] %>% gsub("^o ", "", .)
obj_list <-
# for each title, group its lines into one el in list
list_from_idx(title_idx, group_txt) %>%
# set title names
set_names(c("group", title_list))
}
)
### 5. Write file ===
## 5.1 output dir/file configuration ---
# validate output directory
if(!dir.exists(out_dir)){
dir.create(out_dir)
cat("Output directory", out_dir, "created!\n")
}
# parse file name then create output obj file
out_file_name <-
paste0(out_dir, file_name, ".obj")
file.create(out_file_name, overwrite = TRUE)
if (verbose) cat("Output file", out_file_name, "created,")
## 5.2 writing comment and objects in group_obj_list ---
if (verbose) cat(" writing:\n")
# first write comment (1st element of group_list)
out_file_con <- file(out_file_name, "w")
write(group_list[["comment"]], out_file_con)
if (verbose) cat("comments\n")
# now write object by group from group_obj_list
for (group_idx in 1:length(target_list)){
group_name <- names(target_list)[[group_idx]]
if (verbose) cat("===========================\n")
if (verbose) cat(group_name, "\n")
if (verbose) cat("===========================\n")
for (obj_idx in 1:length(target_list[[group_idx]])){
if (verbose) {
if (obj_idx > 1){ # if obj is not group title
obj_name <- names(target_list[[group_idx]])[obj_idx]
cat(obj_name, "\n")
}
}
# write lines
write(target_list[[group_idx]][[obj_idx]],
out_file_con)
}
if (verbose) cat("\n~~~~~~~~~~~~~~~~~~~~~~~~~\n")
}
# close and cleanup
close(out_file_con)
if (verbose) cat("File Connection closed.\n")
cat("Success!\n")
return(0)
rm(list = ls())
source("./func/osm_helper.R")
require(rgl)
require(dplyr)
require(magrittr)
file_dir <-
"/Users/Jeremiah/Dropbox/Research/Harvard/1. BostonPol/Analysis/Elem/2/data/3d_building_osm"
#### 3. read-in 3d OBJ file and keep only the building objects ####
in_dir <- paste0(file_dir, "/Data_3d/")
out_dir <- paste0(file_dir, "/Data_3d_building/")
file_list <-
list.files(in_dir) %>%
grep("*.obj$", ., value = TRUE) %>%
gsub("\\.obj$", "", .)
# run building extractor
outcome_list <-
vector("list", length(file_list)) %>%
set_names(file_list)
fail_file_list <- character(0)
for (file_name in file_list) {
outcome_list[[file_name]] <-
tryCatch(
obj_filter(file_name, key = "^Building$",
verbose = TRUE,
in_dir = in_dir, out_dir = out_dir),
error = function(e) e)
# record fail file name
if("error" %in% class(outcome_list[[file_name]])){
cat("FAIL!!!\n")
fail_file_list <- c(fail_file_list, file_name)
}
}
source("./func/osm_helper.R")
require(rgl)
require(dplyr)
require(magrittr)
file_dir <-
"/Users/Jeremiah/Dropbox/Research/Harvard/1. BostonPol/Analysis/Elem/2/data/3d_building_osm"
#### 3. read-in 3d OBJ file and keep only the building objects ####
in_dir <- paste0(file_dir, "/Data_3d/")
out_dir <- paste0(file_dir, "/Data_3d_building/")
file_list <-
list.files(in_dir) %>%
grep("*.obj$", ., value = TRUE) %>%
gsub("\\.obj$", "", .)
# run building extractor
outcome_list <-
vector("list", length(file_list)) %>%
set_names(file_list)
fail_file_list <- character(0)
for (file_name in file_list) {
outcome_list[[file_name]] <-
tryCatch(
obj_filter(file_name, key = "^Building$",
verbose = FALSE,
in_dir = in_dir, out_dir = out_dir),
error = function(e) e)
# record fail file name
if("error" %in% class(outcome_list[[file_name]])){
cat("FAIL!!!\n")
fail_file_list <- c(fail_file_list, file_name)
}
}
source("./func/osm_helper.R")
require(rgl)
require(dplyr)
require(magrittr)
file_dir <-
"/Users/Jeremiah/Dropbox/Research/Harvard/1. BostonPol/Analysis/Elem/2/data/3d_building_osm"
#### 3. read-in 3d OBJ file and keep only the building objects ####
in_dir <- paste0(file_dir, "/Data_3d/")
out_dir <- paste0(file_dir, "/Data_3d_building/")
file_list <-
list.files(in_dir) %>%
grep("*.obj$", ., value = TRUE) %>%
gsub("\\.obj$", "", .)
# run building extractor
outcome_list <-
vector("list", length(file_list)) %>%
set_names(file_list)
fail_file_list <- character(0)
for (file_name in file_list) {
outcome_list[[file_name]] <-
tryCatch(
obj_filter(file_name, key = "^Building$",
verbose = FALSE,
in_dir = in_dir, out_dir = out_dir),
error = function(e) e)
# record fail file name
if("error" %in% class(outcome_list[[file_name]])){
cat("FAIL!!!\n")
fail_file_list <- c(fail_file_list, file_name)
}
}
outcome_list
?save
save(outcome_list, file = "outcome_list.RData")
save(fail_file_list, file = "fail_file_list.RData")
fail_file_list
outcome_list
